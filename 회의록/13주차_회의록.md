## 정규 회의록

일시 : 2023.01.19 15:00

범위 : 자바의 정석

강의 : 자바의 정석

활동 : github에 올린 내용 정리본 읽고 공부한 내용에 대해 발표 및 질의응답

정리 : https://github.com/GDSC-Ewha-4th/Study-CS.git

---

류서영

## 제어자

### 제어자(modifier)란?

클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여

제어자는 크게 접근 제어자와 그 외의 제어자로 나뉨

하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, 접근 제어자는 단 하나만 사용할 수 있음

### static - 클래스의, 공통적인

static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

| 대상 | 의미 |
| --- | --- |
| 멤버 변수 | 모든 인스턴스에 공통적으로 사용되는 클래스변수가 됨
클래스변수는 인스턴스를 생성하지 않고도 사용 가능
클래스가 메모리에 로드될 때 생성됨 |
| 메서드 | 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 됨
static메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 있음 |

### final - 마지막의, 변경될 수 없는

final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

| 대상 | 의미 |
| --- | --- |
| 클래스 | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 됨
그래서 final로 지정된 클래스는 다른 클래스의 부모가 될 수 없음 |
| 메서드 | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없음 |
| 멤버변수
지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 됨 |

### 생성자를 이용한 final 멤버변수 초기화

final이 붙은 변수는 상수이므로 보통은 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 할 수 있음

```java
class Card {
	final int NUMBER;
	final String KIND;
	static int width = 100;
	static int height = 250;

	Card(String kind, int num) {
		KIND = kind;
		NUMBER = num;
	}

	Card() {
		this("HEART", 1);
	}

	public String toString() {
		return  "" + KIND + " " + NUMBER;
	}
}
```

### abstract - 추상의, 미완성의

abstract가 사용될 수 있는 곳 - 클래스, 메서드

| 대상 | 의미 |
| --- | --- |
| 클래스 | 클래스 내에 추상메서드가 선언되어 있음을 의미 |
| 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알림 |

### 접근 제어자(access modifier)

멤버 또는 클래스에 사용되어, 외부로부터의 접근을 제한

접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버 변수, 메서드, 생성자

- private - 같은 클래스 내에서만 접근이 가능
- default - 같은 패키지 내에서만 접근이 가능
- protected - 같은 패키지 내에서, 그리고 다른 패키지의 자식클래스에서 접근이 가능
- public - 접근 제한이 전혀 없음

### 접근 제어자를 이용한 캡슐화

접근 제어자를 사용하는 이유

- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

### 생성자의 접근 제어자

일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있음

### 제어자의 조합

| 대상 | 사용가능한 제어자 |
| --- | --- |
| 클래스 | public, (default), final, abstract |
| 메서드 | 모든 접근 제어자, final, abstract, static |
| 멤버변수 | 모든 접근 제어자, final, static |
| 지역변수 | final |
1. 메서드에 static과 abstract를 함께 사용할 수 없음
2. 클래스에 abstract와 final을 동시에 사용할 수 없음
3. abstract메서드의 접근제어자가 private일 수 없음
4. 메서드에 private와 final을 같이 사용할 필요 없음

채지은

**객체 지향 언어의 특징**
* 코드의 재사용성
* 코드 관리가 용이
* 신뢰성이 높은 프로그래밍
    * 제어자와 메서드를 이용해 데이터를 보호하고 올바른 값을 유지하도록 함
    * 코드의 중복을 제거

**클래스와 객체**

클래스란? '객체를 정의해놓은 것', '객체의 설계도 또는 틀' <br/>
클래스는 객체를 생성하는데 사용

프로그래밍에서 객체는 클래스에 정의된 내용대로 메모리에 생성된 것

**객체와 인스턴스**

클래스의 인스턴스화: 클래스로부터 객체를 만드는 과정 <br/>
인스턴스: 어떤 클래스로부터 만들어진 객체 <br/>
=> 결국 객체와 인스턴스는 같은 의미이지만, 
* 객체는 모든 인스턴스를 대표하는 포괄적 의미 (인스턴스는 객체에 포함)
* 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적 의미

객체 vs 인스턴스
* 클래스 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부름

**객체의 속성과 기능**

속성
* = 멤버 변수(member variable) = 특성(attribute) = 필드(field) = 상태(state)

기능
* = 메서드(method) = 함수(function) = 행위(behavior)

**인스턴스의 생성과 사용**
```
Tv t;   // Tv 클래스 타입의 참조변수 t 생성
t = new Tv();   // 생성된 Tv 인스턴스의 주소를 t에 저장
```

인스턴스는 참조 변수를 통해서만 다룰 수 있으며, 참조 변수의 타입은 인스턴스의 타입과 일치해야 한다.

```
Tv t1 = new Tv();
Tv t2 = new Tv();
```

---

**선언위치에 따른 변수의 종류**
```
class Variables{
    int iv;             // 인스턴스 변수
    static int cv;      // 클래스 변수(static 변수, 공유 변수)
    void method(){
        int lv = 0;     // 지역 변수
    }
}
```
* 클래스 변수(class variable)
    * 클래스가 메모리에 올라갈 때 생성
    * 모든 인스턴스가 공통된 저장공간을 공유
* 인스턴스 변수(instance variable)
    * 인스턴스가 생성되었을 때
    * 인스턴스마다 서로 다른 값 (인스턴스는 독립적인 저장공간을 가지므로)
* 지역 변수(local variable)
    * 변수 선언문이 수행되었을 때

---

**메서드**
* 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것

사용하는 이유
* 높은 재사용성
* 중복 코드 제거
* 프로그램의 구조화

---

**JVM의 메모리 구조**

<img src="https://user-images.githubusercontent.com/86587287/213128398-cbd59dfe-0671-426b-a958-3ec50ee77ab3.png" width=400px>

**메서드 영역(Method Area)**
* 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스 파일 (*.class)을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다. 이 때, 그 클래스의 클래스 변수(=static 변수)도 이영역에 함께 생성

**힙(Heap)**
* 인스턴스가 생성되는 공간.
* 즉, 인스턴스 변수들이 생성되는 공간이다.

**호출 스택(call stack 또는 execution stack)**
* 메서드의 작업에 필요한 메모리 공간을 제공
* 메서드가 호출되면, 호출 스택에 호출된 메서드를 위한 메모리가 할당되며, 메서드가 작업을 수행하는 동안 지역 변수들과 연산의 중간결과 등을 저장하는데 사용
* 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워짐