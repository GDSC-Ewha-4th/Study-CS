## __🦈 Logical vs Physical Address__

프로세스 실행 과정에서 메모리

디스크(파일 시스템)에 프로그램 A, B <br/>
-> 프로세스 A,B의 Logical Address (가상 메모리)가 만들어짐 (각각 0부터 시작)
-> 메모리에 올라감(물리적 주소) (이 때, 맨 아래(0)에는 운영체제 존재) 가상 주소 -> 물리 주소 변환

🐬 Logical Address
프로세스마다 독립적으로 가지는 주소 공간
각 프로세스마다 0번지부터 시작
CPU가 보는 주소는 Logical address임
* CPU는 HW니깐 memory의 Physical 주소를 볼 것 같지만 그렇진 않음
* -> 기계어 하나하나의 주소가 논리적 주소 (실행파일에서 컴파일 될 때의 주소가 논리적 주소니깐..)


🐬 Physical Address
메모리에 실제 올라가는 주소(위치)

주소 바인딩: 주소를 결정하는 것
Symbolic Address -> Logical Address -> Physical Address
프로그래머가 메모리를 바라볼 땐 Symbolic address(변수)

이 때, Logical Address -> Physical Address (주소변환=주소 바인딩) 시점은?

<img src="https://user-images.githubusercontent.com/86587287/197707825-f5a26c2c-3111-4c0c-a523-40c0985bbce5.png" width=450px>

Compile Time Binding
소스코드 -컴파일-> 실행파일(Logical) -실행시작-> 물리적 메모리
* 컴파일 시점에 물리적 주소로 변환(binding)
* 비효율적 (realtime이 필요한 OS 아닌 이상..)
* 절대 코드(=> 주소 변환 필요 없이 그대로 메모리에 갖다 쓰면 되니깐..) absolute code

Load Time Binding
* 실행이 시작되는 시점에 물리적 메모리 주소가 배정됨 & 안 바뀜
* 재배치 가능 코드 (컴파일러가 재배치 가능) relocatable code

Excution time binding (Runtime binding)
* 프로그램 실행 시작될 때 물리적 주소가 배정되는건 같지만 & 이후 메모리 상 위치 옮길 수 있음
* CPU가 주소를 참조할 때마다 binding을 참조(address mapping table)
* -> HW적 지원이 필요 (MMU)

MMU (Memory-Management Unit)
* logical addr -> physical addr 매핑

<img src="https://user-images.githubusercontent.com/86587287/197710539-cfe83850-14b3-4971-9e2d-f75c334690b8.png" width=450px>

프로세스의 logical addr --MMU(base register + offset?(프로세스 시작에서부터 요청하는 주소의 위치))--> physical addr
relocation 레지스터: 물리적 주소에서의 시작
limit 레지스터: 프로세스의 크기 (프로세스 밖의 physical 주소를 요청하는 악의적 메모리 접근 시도를 방지)

Loading: 메모리로 올리는 것

Dynamic Loading
* 프로세스 전체를 메모리에 미리 다 올리지 X, 해당 루틴이 불려질 때 메모리에 load
* memory utilization 향상

Overlay
* 메모리에 프로세스의 부분 중 실제 필요한 정보만 올리는 것
* 프로세스의 크기가 메모리보다 클 때 유용
* 프로그래머에 의해 구현->복잡
* 메모리가 작던 시절..

Swapping
* 프로세스를 메모리->backing store(디스크)로 쫓아내는 것
* 중기 스케줄러에 의해 swap out
* 컴파일 타임 혹은 로드 타임에 원래 메모리 위치로 swap in
* 양이 많기 때문에 swap time 중 대부분이 transfer time임(탐색 시간 (Seek Time) + 회전 지연 (Rotational Latency) + 전송 시간 (Transfer Time))
* 전체를 swapping (일부 페이지만 swapping할 수도 있음)

Dynamic Linking (Shared Library, Shared object = .so, .dll)
* Linking을 실행시간(Execution time)까지 미루는 기법
* 내가 만든 것이 아닌 코드 (라이브러리)
* Static Linking (Static Library)
    * 라이브러리가 프로그램의 실행 파일(Logical Address) 코드에 포함
    * ex) 같은 일을하는 printf라는 코드가 각 프로그램에 포함 -> 낭비
* 라이브러리가 실행시 연결 됨
* 라이브러리 호출 부분에 stub(라이브러리 루틴의 위치를 찾는)라는 작은 코드를 둠
* 라이브러리가 메모리에 있으면 그 루틴의 주소로, 없으면 디스크에서 읽어옴
