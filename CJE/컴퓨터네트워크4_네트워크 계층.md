아래 계층의 과정에 대해서 위에 계층은 몰라도 됨 (블랙박스) <br/>
=> transport layer에서 내려온 segment를 network layer에서 처리

<img src="https://user-images.githubusercontent.com/86587287/204462731-68be9a18-21a1-40e5-be38-c490be79c44a.png" width=500px>

packet = (TCP/UDP) segment + network layer header

**Router** => forwarding, routing
* forwarding
    * 라우터의 forwarding table을 보고 패킷 헤더의 목적지를 보고 알맞은 경로로 전달
* routing
    * forwarding table을 채워넣음
    * 길 찾기 알고리즘
    * ex) 서울시 도봉구 -> 0번으로, 서울시 노원구 -> 1번으로
        * 도봉구 창5동 -> 0번으로, 도봉구 창1동 -> 1번으로 ...
    * **Longest prefix matching** - 가장 길게 일치하는 address range로 매칭

**Router 구조**

<img src="https://user-images.githubusercontent.com/86587287/204464552-2a448e53-fa77-4522-912b-774ca6b4a917.png" width=400px>

* routing processor(control plane, 나머지: data plane)에서 forwarding table 만듦
* input port마다 각각 forwarding table 존재
    * 해당 포트로 들어오는 패킷을 그에 맞는 entry에 따라 처리
    * 처리하는 속도보다 빠르게 들어오면 큐에서 대기

**IP packet format**

<img src="https://user-images.githubusercontent.com/86587287/204464703-f2592ba3-0cc0-437f-b401-43e9951e8b00.png" width=400px>

* TTL(time to live): 패킷이 무한히 살아남으면 안 됨 -> 수명 제한
* Upper layer protocol: 목적지에 도착했을 때, 상위 계층인 transport layer의 프로토콜이 무엇인지?    
    * 패킷의 data에 무엇이 들어있는지? ex) TCP Segment

**IP Address (IPv4)**
* unique 32 bit number
* Identifies an interface (on a host, on a router) <br/>
=> 네트워크 인터페이스를 지칭 (머신 자체를 지칭하는 것이 아님) <br/>
=> 라우터에는 네트워크 인터페이스가 여러 개

**Scalability Challenge => 계층화**
* IP address를 무작위로 `1.2.3.4`, `5.6.7.8` 무작위 배정 <br/>
-> 라우터의 forwarding table이 아주 커져야 함..

IP addr => Network ID(=prefix, subnet) 부분과 Host ID 부분으로 나눔 <br/>
=> forwarding table이 단순해짐 & 관리 쉬움 <br/>
<img src="https://user-images.githubusercontent.com/86587287/204581295-7931ab89-9554-422d-9352-d174f2c509ae.png" width=400px>

**CIDR**
* 각 기관 크기에 맞게 유연하게 prefix 사이즈를 배정
* 큰 기관에는 prefix 8 지원 -> 2^24만큼 host 가능

**subnet mask == network prefix == prefix** <br/>
-> 어디까지가 network id인지 기계들이 알아듣게 하기 위해.. <br/>
-> /로 prefix 구분하는 것 <br/>
subnet mask: 11111111 11111111 11111111 00000000 => prefix: /24

포워딩 테이블의 엔트리는 prefix 단위로 배정
* dest addr: 201.10.6.17
* forwarding table
    * 4.0.0.0/8
    * 201.10.0.0/21
    * 201.10.6.0/23 => 가장 길게 맞으므로 선택 (Longest prefix matching)

**subnet**
* device interfaces with same subnet part(=network id) of IP addr
* 같은 네트워크 인터페이스를 공유

라우터: 네트워크 인터페이스를 여러개 가짐
* **여러 서브넷에 공통적으로 속함** <br/>
-> 다른 서브넷에 접속하기 위해서는 그 서브넷과 현재 위치한 서브넷에 공통적으로 속한 라우터를 거쳐야만 함

서브넷에 꼭 호스트가 존재하진 않음 <br/>
<img src="https://user-images.githubusercontent.com/86587287/204582571-d4f38b89-9194-4ae7-8203-162dc7e55b6f.png" width=300px> <br/>
=> 6개의 서브넷